<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sumant Hub</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #1e1e2f, #2a2a4e, #3b1a6d);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
        }
        .game-section {
            display: none;
            text-align: center;
            padding: clamp(15px, 5vw, 20px);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .game-section.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        .main-menu {
            display: flex;
            flex-wrap: wrap;
            gap: clamp(8px, 2vw, 12px);
            justify-content: center;
            padding: 20px;
        }
        button {
            padding: clamp(10px, 3vw, 15px) clamp(20px, 5vw, 30px);
            font-size: clamp(16px, 4vw, 18px);
            background: linear-gradient(45deg, #ff2e63, #ff6b6b);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transform: perspective(500px) translateZ(0);
            transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            font-weight: 600;
        }
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }
        button:hover::before {
            width: 200px;
            height: 200px;
        }
        button:hover {
            transform: perspective(500px) translateZ(10px) translateY(-5px);
            background: linear-gradient(45deg, #ff6b6b, #ff2e63);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.5);
        }
        button:active {
            transform: perspective(500px) translateZ(5px);
        }
        canvas {
            background: #111;
            border: 2px solid #00f6ff;
            border-radius: 10px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            max-width: 100%;
            height: auto;
        }
        canvas:hover {
            transform: scale(1.03);
            box-shadow: 0 0 20px rgba(0, 246, 255, 0.5);
        }
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00f6ff;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }
        .particle.star {
            background: #ffeb3b;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
        }
        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1) translate(0, 0); }
            100% { opacity: 0; transform: scale(0) translate(var(--tx), var(--ty)); }
        }
        .ludo-cell {
            width: clamp(25px, 6vw, 30px);
            height: clamp(25px, 6vw, 30px);
            background: #333;
            border: 1px solid #555;
            display: inline-block;
            position: relative;
            border-radius: 4px;
        }
        .ludo-piece {
            width: clamp(18px, 4vw, 20px);
            height: clamp(18px, 4vw, 20px);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            transition: all 0.4s ease-in-out;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        .ludo-piece:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        .ludo-piece-blue { background: linear-gradient(45deg, #0288d1, #4fc3f7); }
        .ludo-piece-red { background: linear-gradient(45deg, #d32f2f, #f44336); }
        .tictactoe-cell {
            background: #fff;
            color: #000;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        .tictactoe-cell:hover {
            background: #e0f7fa;
            transform: scale(1.05);
        }
        .message-box {
            margin-top: 15px;
            font-size: clamp(16px, 4vw, 18px);
            font-weight: 600;
            text-shadow: 0 0 5px rgba(0, 246, 255, 0.5);
            transition: opacity 0.5s ease;
        }
        .win-animation {
            animation: winPulse 1.5s ease-in-out infinite;
        }
        @keyframes winPulse {
            0% { transform: scale(1); text-shadow: 0 0 5px rgba(0, 246, 255, 0.5); }
            50% { transform: scale(1.1); text-shadow: 0 0 10px rgba(0, 246, 255, 0.8); }
            100% { transform: scale(1); text-shadow: 0 0 5px rgba(0, 246, 255, 0.5); }
        }
        h1 {
            font-size: clamp(2rem, 6vw, 2.5rem);
            color: #00f6ff;
            text-shadow: 0 0 10px rgba(0, 246, 255, 0.8);
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite;
        }
        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(0, 246, 255, 0.8); }
            50% { text-shadow: 0 0 20px rgba(0, 246, 255, 1); }
            100% { text-shadow: 0 0 10px rgba(0, 246, 255, 0.8); }
        }
        :root {
            --glow-color: #00f6ff;
            --accent-color: #ff5555;
            --box-shadow-dark: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        @media (max-width: 768px) {
            body { padding: 10px; }
            .main-menu { gap: 8px; }
            canvas { width: 100%; max-width: 350px; height: auto; }
            .tictactoe-cell { width: clamp(80px, 25vw, 90px); height: clamp(80px, 25vw, 90px); font-size: clamp(2em, 8vw, 2.5em); }
        }
        @media (max-width: 480px) {
            button { padding: 8px 15px; font-size: clamp(14px, 4vw, 16px); }
            .message-box { font-size: clamp(14px, 4vw, 16px); }
            .ludo-cell { width: clamp(20px, 5vw, 25px); height: clamp(20px, 5vw, 25px); }
            .ludo-piece { width: clamp(14px, 4vw, 16px); height: clamp(14px, 4vw, 16px); }
        }
    </style>
</head>
<body>
    <div id="menu" class="game-section active">
        <h1>Sumant Hub</h1>
        <div class="main-menu">
            <button onclick="showGame('flappy')">Flappy Bird</button>
            <button onclick="showGame('ludo')">Ludo vs Sumant</button>
            <button onclick="showGame('tictactoe')">Tic-Tac-Toe</button>
            <button onclick="showGame('snake')">Snake</button>
            <button onclick="showGame('bubble')">Bubble Shooter</button>
        </div>
    </div>
    <div id="flappy" class="game-section">
        <canvas id="flappyCanvas" width="400" height="600"></canvas>
        <div id="flappy-message" class="message-box"></div>
        <button id="flappy-replay" style="display: none;" onclick="flappyGame.reset()">Play Again</button>
        <button onclick="showGame('menu')">Back to Menu</button>
    </div>
    <div id="ludo" class="game-section">
        <div id="ludo-board" style="display: grid; grid-template-columns: repeat(15, clamp(20px, 6vw, 30px));"></div>
        <div id="ludo-message" class="message-box"></div>
        <button onclick="ludoGame.rollLudoDice()">Roll Dice</button>
        <button id="ludo-replay" style="display: none;" onclick="ludoGame.reset()">Play Again</button>
        <button onclick="showGame('menu')">Back to Menu</button>
    </div>
    <div id="tictactoe" class="game-section">
        <div id="tictactoe-board"></div>
        <div id="tictactoe-message" class="message-box"></div>
        <button id="tictactoe-replay" style="display: none;" onclick="tictactoeGame.reset()">Play Again</button>
        <button onclick="showGame('menu')">Back to Menu</button>
    </div>
    <div id="snake" class="game-section">
        <canvas id="snakeCanvas" width="400" height="400"></canvas>
        <div id="snake-message" class="message-box"></div>
        <button id="snake-replay" style="display: none;" onclick="snakeGame.reset()">Play Again</button>
        <button onclick="showGame('menu')">Back to Menu</button>
    </div>
    <div id="bubble" class="game-section">
        <canvas id="bubbleCanvas" width="400" height="400"></canvas>
        <div id="bubble-message" class="message-box"></div>
        <button id="bubble-replay" style="display: none;" onclick="bubbleGame.reset()">Play Again</button>
        <button onclick="showGame('menu')">Back to Menu</button>
    </div>

    <script>
        // --- Utility for Particle Effects ---
        function createParticles(x, y, container, count = 10, type = 'circle') {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                if (type === 'star' || Math.random() > 0.5) particle.classList.add('star');
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                const tx = (Math.random() - 0.5) * 60;
                const ty = (Math.random() - 0.5) * 60;
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                particle.style.background = Math.random() > 0.5 ? '#00f6ff' : '#ffeb3b';
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
        }

        // --- Game Manager ---
        let flappyGame, ludoGame, tictactoeGame, snakeGame, bubbleGame;
        function showGame(gameId) {
            document.querySelectorAll('.game-section').forEach(section => {
                section.classList.remove('active');
            });
            const targetSection = document.getElementById(gameId);
            targetSection.classList.add('active');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, document.body, 15, 'star');
            if (gameId !== 'menu') {
                startGame(gameId);
            }
        }

        function startGame(gameId) {
            switch (gameId) {
                case 'flappy': flappyGame = new FlappyGame('flappyCanvas'); break;
                case 'ludo': ludoGame = new LudoGame('ludo-board'); break;
                case 'tictactoe': tictactoeGame = new TicTacToeGame('tictactoe-board'); break;
                case 'snake': snakeGame = new SnakeGame('snakeCanvas'); break;
                case 'bubble': bubbleGame = new BubbleShooterGame('bubbleCanvas'); break;
            }
        }

        // --- Flappy Bird Game ---
        class FlappyGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('flappy-message');
                this.replayButton = document.getElementById('flappy-replay');
                this.bird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2 };
                this.pipes = [];
                this.score = 0;
                this.isPlaying = false;
                this.lastTime = 0;
                this.canvas.addEventListener('click', () => this.flap());
                this.canvas.addEventListener('touchstart', () => this.flap());
                this.reset();
            }

            reset() {
                this.bird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2 };
                this.pipes = [];
                this.score = 0;
                this.messageBox.style.display = 'none';
                this.replayButton.style.display = 'none';
                this.isPlaying = true;
                this.pipes.push(this.createPipe());
                this.gameLoop(0);
            }

            createPipe() {
                const gap = 150;
                const minHeight = 50;
                const maxHeight = this.canvas.height - gap - minHeight;
                const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
                return {
                    x: this.canvas.width,
                    width: 50,
                    topHeight,
                    bottomHeight: this.canvas.height - topHeight - gap,
                    gapY: topHeight + gap,
                    passed: false
                };
            }

            flap() {
                if (this.isPlaying) {
                    this.bird.velocity = -5;
                    createParticles(this.bird.x, this.bird.y, this.canvas.parentElement, 12, 'star');
                }
            }

            update(delta) {
                if (!this.isPlaying) return;
                const dt = delta / 16.67;
                this.bird.velocity += this.bird.gravity * dt;
                this.bird.y += this.bird.velocity * dt;
                this.pipes.forEach(pipe => {
                    pipe.x -= 2 * dt;
                    if (this.bird.x > pipe.x + pipe.width && !pipe.passed) {
                        pipe.passed = true;
                        this.score++;
                        createParticles(this.bird.x, this.bird.y, this.canvas.parentElement, 15, 'star');
                    }
                    if (this.bird.x + this.bird.size > pipe.x && this.bird.x < pipe.x + pipe.width) {
                        if (this.bird.y < pipe.topHeight || this.bird.y + this.bird.size > pipe.gapY) {
                            this.gameOver();
                        }
                    }
                });
                if (this.bird.y <= 0 || this.bird.y >= this.canvas.height) {
                    this.gameOver();
                }
                if (this.pipes.length > 0 && this.pipes[this.pipes.length - 1].x < this.canvas.width - 200) {
                    this.pipes.push(this.createPipe());
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = 'linear-gradient(45deg, #ffeb3b, #ffc107)';
                this.ctx.fillRect(this.bird.x, this.bird.y, this.bird.size, this.bird.size);
                this.ctx.fillStyle = 'linear-gradient(45deg, #4caf50, #81c784)';
                this.pipes.forEach(pipe => {
                    this.ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                    this.ctx.fillRect(pipe.x, pipe.gapY, pipe.width, this.canvas.height - pipe.gapY);
                });
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '20px Poppins';
                this.ctx.fillText(`Score: ${this.score}`, 10, 30);
            }

            gameLoop = (timestamp) => {
                if (!this.lastTime) this.lastTime = timestamp;
                const delta = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(delta);
                this.draw();
                if (this.isPlaying) {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            gameOver() {
                this.isPlaying = false;
                this.messageBox.innerText = `Game Over! Your Score: ${this.score}`;
                this.messageBox.style.display = 'block';
                this.messageBox.classList.add('win-animation');
                this.replayButton.style.display = 'inline-block';
                createParticles(this.canvas.width / 2, this.canvas.height / 2, this.canvas.parentElement, 20, 'star');
            }
        }

        // --- Ludo vs Sumant ---
        class LudoGame {
            constructor(boardId) {
                this.boardElement = document.getElementById(boardId);
                this.messageElement = document.getElementById('ludo-message');
                this.replayButton = document.getElementById('ludo-replay');
                this.board = this.createBoard();
                this.currentPlayer = 'player';
                this.pieces = {
                    player: [{id: 'p1', pos: -1}, {id: 'p2', pos: -1}],
                    sumant: [{id: 's1', pos: -1}, {id: 's2', pos: -1}]
                };
                this.path = this.createPath();
                this.isPlaying = true;
                this.renderBoard();
                this.setMessage("Player's turn. Roll the dice!");
            }

            reset() {
                this.board = this.createBoard();
                this.currentPlayer = 'player';
                this.pieces = {
                    player: [{id: 'p1', pos: -1}, {id: 'p2', pos: -1}],
                    sumant: [{id: 's1', pos: -1}, {id: 's2', pos: -1}]
                };
                this.isPlaying = true;
                this.messageElement.style.display = 'none';
                this.replayButton.style.display = 'none';
                this.renderBoard();
                this.setMessage("Player's turn. Roll the dice!");
                createParticles(this.boardElement.offsetWidth / 2, this.boardElement.offsetHeight / 2, this.boardElement, 15, 'star');
            }

            createBoard() {
                return new Array(15).fill(0).map(() => new Array(15).fill(0));
            }

            createPath() {
                return [
                    {x: 7, y: 1}, {x: 7, y: 2}, {x: 7, y: 3}, {x: 7, y: 4}, {x: 7, y: 5},
                    {x: 6, y: 6}, {x: 5, y: 6}, {x: 4, y: 6}, {x: 3, y: 6}, {x: 2, y: 6},
                    {x: 1, y: 6}, {x: 0, y: 7}, {x: 1, y: 8}, {x: 2, y: 8}, {x: 3, y: 8},
                    {x: 4, y: 8}, {x: 5, y: 8}, {x: 6, y: 9}, {x: 7, y: 10}, {x: 7, y: 11},
                    {x: 7, y: 12}, {x: 7, y: 13}, {x: 7, y: 14}
                ];
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                for (let i = 0; i < 15; i++) {
                    for (let j = 0; j < 15; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('ludo-cell');
                        this.boardElement.appendChild(cell);
                    }
                }
                this.renderPieces();
            }

            renderPieces() {
                this.pieces.player.forEach(p => {
                    if (p.pos !== -1) {
                        const cell = this.boardElement.children[this.path[p.pos].y * 15 + this.path[p.pos].x];
                        const piece = document.createElement('div');
                        piece.classList.add('ludo-piece', 'ludo-piece-blue');
                        piece.onclick = () => this.movePiece(p, this.lastRoll || 6);
                        cell.appendChild(piece);
                        createParticles(cell.offsetLeft + 15, cell.offsetTop + 15, this.boardElement, 10, 'star');
                    }
                });
                this.pieces.sumant.forEach(p => {
                    if (p.pos !== -1) {
                        const cell = this.boardElement.children[this.path[p.pos].y * 15 + this.path[p.pos].x];
                        const piece = document.createElement('div');
                        piece.classList.add('ludo-piece', 'ludo-piece-red');
                        cell.appendChild(piece);
                        createParticles(cell.offsetLeft + 15, cell.offsetTop + 15, this.boardElement, 10, 'star');
                    }
                });
            }

            setMessage(msg) {
                this.messageElement.innerText = msg;
                this.messageElement.classList.remove('win-animation');
                if (msg.includes('wins') || msg.includes('finished')) {
                    this.messageElement.classList.add('win-animation');
                }
            }

            rollLudoDice() {
                if (this.currentPlayer !== 'player') {
                    this.setMessage("It's not your turn!");
                    return;
                }
                this.lastRoll = Math.floor(Math.random() * 6) + 1;
                this.setMessage(`You rolled a ${this.lastRoll}. Click a piece to move.`);
                createParticles(this.boardElement.offsetWidth / 2, this.boardElement.offsetHeight / 2, this.boardElement, 15, 'star');
                this.currentPlayer = 'sumant';
                setTimeout(() => this.sumantTurn(), 1000);
            }

            movePiece(piece, steps) {
                if (piece.pos === -1 && steps === 6) {
                    piece.pos = 0;
                } else if (piece.pos !== -1) {
                    piece.pos += steps;
                    if (piece.pos >= this.path.length) {
                        this.setMessage(`${this.currentPlayer} finished the game!`);
                        this.isPlaying = false;
                        this.messageElement.style.display = 'block';
                        this.replayButton.style.display = 'inline-block';
                        createParticles(this.boardElement.offsetWidth / 2, this.boardElement.offsetHeight / 2, this.boardElement, 20, 'star');
                    }
                }
                this.renderBoard();
            }

            sumantTurn() {
                if (!this.isPlaying) return;
                this.setMessage("Sumant's turn...");
                const diceRoll = Math.floor(Math.random() * 6) + 1;
                setTimeout(() => {
                    this.setMessage(`Sumant rolled a ${diceRoll}.`);
                    const movablePieces = this.pieces.sumant.filter(p => p.pos !== -1 || diceRoll === 6);
                    const piece = movablePieces.sort((a, b) => (b.pos || -1) - (a.pos || -1))[0];
                    if (piece) {
                        this.movePiece(piece, diceRoll);
                    }
                    this.currentPlayer = 'player';
                    this.setMessage("Player's turn. Roll the dice!");
                }, 1000);
            }
        }

        // --- Tic-Tac-Toe Game ---
        class TicTacToeGame {
            constructor(boardId) {
                this.boardElement = document.getElementById(boardId);
                this.messageElement = document.getElementById('tictactoe-message');
                this.replayButton = document.getElementById('tictactoe-replay');
                this.board = ['', '', '', '', '', '', '', '', ''];
                this.currentPlayer = 'X';
                this.isGameActive = true;
                this.winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                this.boardElement.style.display = 'grid';
                this.boardElement.style.gridTemplateColumns = 'repeat(3, 1fr)';
                this.boardElement.style.gap = '5px';
                this.boardElement.style.width = 'clamp(240px, 80vw, 300px)';
                this.boardElement.style.height = 'clamp(240px, 80vw, 300px)';
                this.reset();
            }

            reset() {
                this.board = ['', '', '', '', '', '', '', '', ''];
                this.isGameActive = true;
                this.currentPlayer = 'X';
                this.messageElement.innerText = "Player X's turn";
                this.messageElement.style.display = 'block';
                this.replayButton.style.display = 'none';
                this.renderBoard();
                createParticles(this.boardElement.offsetWidth / 2, this.boardElement.offsetHeight / 2, this.boardElement, 15, 'star');
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                this.board.forEach((cell, index) => {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('tictactoe-cell');
                    cellElement.style.width = 'clamp(80px, 25vw, 100px)';
                    cellElement.style.height = 'clamp(80px, 25vw, 100px)';
                    cellElement.style.display = 'flex';
                    cellElement.style.justifyContent = 'center';
                    cellElement.style.alignItems = 'center';
                    cellElement.style.fontSize = 'clamp(2em, 8vw, 3em)';
                    cellElement.style.backgroundColor = 'white';
                    cellElement.style.color = cell === 'X' ? '#ff2e63' : '#0288d1';
                    cellElement.style.cursor = 'pointer';
                    cellElement.style.borderRadius = '8px';
                    cellElement.innerText = cell;
                    cellElement.addEventListener('click', () => this.handleCellClick(index));
                    cellElement.addEventListener('touchstart', () => this.handleCellClick(index));
                    this.boardElement.appendChild(cellElement);
                    if (cell) {
                        createParticles(cellElement.offsetLeft + 50, cellElement.offsetTop + 50, this.boardElement, 10, 'star');
                    }
                });
            }

            handleCellClick(index) {
                if (!this.isGameActive || this.board[index] !== '') return;
                this.board[index] = this.currentPlayer;
                this.renderBoard();
                if (this.checkWin()) {
                    this.messageElement.innerText = `${this.currentPlayer} wins!`;
                    this.messageElement.classList.add('win-animation');
                    this.isGameActive = false;
                    this.replayButton.style.display = 'inline-block';
                    createParticles(this.boardElement.offsetWidth / 2, this.boardElement.offsetHeight / 2, this.boardElement, 20, 'star');
                    return;
                }
                if (this.checkDraw()) {
                    this.messageElement.innerText = "It's a draw!";
                    this.messageElement.classList.add('win-animation');
                    this.isGameActive = false;
                    this.replayButton.style.display = 'inline-block';
                    createParticles(this.boardElement.offsetWidth / 2, this.boardElement.offsetHeight / 2, this.boardElement, 15, 'star');
                    return;
                }
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                this.messageElement.innerText = `${this.currentPlayer}'s turn`;
                if (this.currentPlayer === 'O') {
                    setTimeout(() => this.computerMove(), 500);
                }
            }

            checkWin() {
                return this.winPatterns.some(pattern => {
                    return pattern.every(index => this.board[index] === this.currentPlayer);
                });
            }

            checkDraw() {
                return this.board.every(cell => cell !== '');
            }

            computerMove() {
                if (!this.isGameActive) return;
                let bestMove = this.getBestMove();
                if (bestMove !== null) {
                    this.handleCellClick(bestMove);
                }
            }

            getBestMove() {
                let bestScore = -Infinity;
                let move;
                for (let i = 0; i < this.board.length; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = 'O';
                        let score = this.minimax(this.board, 0, false);
                        this.board[i] = '';
                        if (score > bestScore) {
                            bestScore = score;
                            move = i;
                        }
                    }
                }
                return move;
            }

            minimax(board, depth, isMaximizing) {
                if (this.checkWin('O')) return 10 - depth;
                if (this.checkWin('X')) return depth - 10;
                if (this.checkDraw()) return 0;

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            let score = this.minimax(board, depth + 1, false);
                            board[i] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            let score = this.minimax(board, depth + 1, true);
                            board[i] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            }

            checkWin(player) {
                return this.winPatterns.some(pattern => {
                    return pattern.every(index => this.board[index] === player);
                });
            }
        }

        // --- Snake Game ---
        class SnakeGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('snake-message');
                this.replayButton = document.getElementById('snake-replay');
                this.gridSize = 20;
                this.tileCount = this.canvas.width / this.gridSize;
                this.snake = [{ x: 10, y: 10 }];
                this.robotSnake = [{ x: 5, y: 5 }];
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.robotDx = 1;
                this.robotDy = 0;
                this.score = 0;
                this.robotScore = 0;
                this.isPlaying = false;
                this.lastTime = 0;
                document.addEventListener('keydown', this.changeDirection.bind(this));
                this.canvas.addEventListener('touchstart', this.handleTouch.bind(this));
                this.reset();
            }

            reset() {
                this.snake = [{ x: 10, y: 10 }];
                this.robotSnake = [{ x: 5, y: 5 }];
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.robotDx = 1;
                this.robotDy = 0;
                this.score = 0;
                this.robotScore = 0;
                this.isPlaying = true;
                this.messageBox.style.display = 'none';
                this.replayButton.style.display = 'none';
                this.gameLoop(0);
                createParticles(this.canvas.width / 2, this.canvas.height / 2, this.canvas.parentElement, 15, 'star');
            }

            changeDirection(e) {
                if (e.key === 'ArrowUp' && this.dy !== 1) { this.dx = 0; this.dy = -1; }
                else if (e.key === 'ArrowDown' && this.dy !== -1) { this.dx = 0; this.dy = 1; }
                else if (e.key === 'ArrowLeft' && this.dx !== 1) { this.dx = -1; this.dy = 0; }
                else if (e.key === 'ArrowRight' && this.dx !== -1) { this.dx = 1; this.dy = 0; }
            }

            handleTouch(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                const head = this.snake[0];
                const dx = touchX - (head.x * this.gridSize);
                const dy = touchY - (head.y * this.gridSize);
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0 && this.dx !== -1) { this.dx = 1; this.dy = 0; }
                    else if (dx < 0 && this.dx !== 1) { this.dx = -1; this.dy = 0; }
                } else {
                    if (dy > 0 && this.dy !== -1) { this.dx = 0; this.dy = 1; }
                    else if (dy < 0 && this.dy !== 1) { this.dx = 0; this.dy = -1; }
                }
            }

            robotMove() {
                const head = this.robotSnake[0];
                const dxToFood = this.food.x - head.x;
                const dyToFood = this.food.y - head.y;
                if (Math.abs(dxToFood) > Math.abs(dyToFood)) {
                    this.robotDx = dxToFood > 0 ? 1 : -1;
                    this.robotDy = 0;
                } else {
                    this.robotDx = 0;
                    this.robotDy = dyToFood > 0 ? 1 : -1;
                }
                const nextHead = { x: head.x + this.robotDx, y: head.y + this.robotDy };
                if (this.robotSnake.some(segment => segment.x === nextHead.x && segment.y === nextHead.y)) {
                    this.robotDx = -this.robotDx;
                    this.robotDy = -this.robotDy;
                }
            }

            update(delta) {
                if (!this.isPlaying) return;
                const dt = Math.min(delta / 100, 1);
                const head = { x: this.snake[0].x + this.dx * dt, y: this.snake[0].y + this.dy * dt };
                if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount || this.snake.some(segment => Math.abs(segment.x - head.x) < 0.5 && Math.abs(segment.y - head.y) < 0.5)) {
                    this.gameOver();
                    return;
                }
                this.snake.unshift(head);
                if (Math.abs(head.x - this.food.x) < 0.5 && Math.abs(head.y - this.food.y) < 0.5) {
                    this.score++;
                    this.food = { x: Math.floor(Math.random() * this.tileCount), y: Math.floor(Math.random() * this.tileCount) };
                    createParticles(this.food.x * this.gridSize, this.food.y * this.gridSize, this.canvas.parentElement, 12, 'star');
                } else {
                    this.snake.pop();
                }
                this.robotMove();
                const robotHead = { x: this.robotSnake[0].x + this.robotDx * dt, y: this.robotSnake[0].y + this.robotDy * dt };
                if (robotHead.x < 0 || robotHead.x >= this.tileCount || robotHead.y < 0 || robotHead.y >= this.tileCount || this.robotSnake.some(segment => Math.abs(segment.x - robotHead.x) < 0.5 && Math.abs(segment.y - robotHead.y) < 0.5)) {
                    this.robotScore = -1;
                } else {
                    this.robotSnake.unshift(robotHead);
                    if (Math.abs(robotHead.x - this.food.x) < 0.5 && Math.abs(robotHead.y - this.food.y) < 0.5) {
                        this.robotScore++;
                        this.food = { x: Math.floor(Math.random() * this.tileCount), y: Math.floor(Math.random() * this.tileCount) };
                        createParticles(this.food.x * this.gridSize, this.food.y * this.gridSize, this.canvas.parentElement, 12, 'star');
                    } else {
                        this.robotSnake.pop();
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = 'linear-gradient(45deg, #4caf50, #81c784)';
                this.snake.forEach(segment => {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                });
                this.ctx.fillStyle = 'linear-gradient(45deg, #ff2e63, #ff6b6b)';
                this.robotSnake.forEach(segment => {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                });
                this.ctx.fillStyle = 'linear-gradient(45deg, #ffeb3b, #ffc107)';
                this.ctx.fillRect(this.food.x * this.gridSize, this.food.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '20px Poppins';
                this.ctx.fillText(`Player Score: ${this.score}`, 10, 30);
                this.ctx.fillText(`Robot Score: ${this.robotScore}`, 10, 60);
            }

            gameLoop = (timestamp) => {
                if (!this.lastTime) this.lastTime = timestamp;
                const delta = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(delta);
                this.draw();
                if (this.isPlaying) {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            gameOver() {
                this.isPlaying = false;
                this.messageBox.innerText = `Game Over! Your Score: ${this.score}, Robot Score: ${this.robotScore}`;
                this.messageBox.style.display = 'block';
                this.messageBox.classList.add('win-animation');
                this.replayButton.style.display = 'inline-block';
                createParticles(this.canvas.width / 2, this.canvas.height / 2, this.canvas.parentElement, 20, 'star');
            }
        }

        // --- Bubble Shooter Game ---
        class BubbleShooterGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('bubble-message');
                this.replayButton = document.getElementById('bubble-replay');
                this.bubbles = [];
                this.shooter = { x: this.canvas.width / 2, y: this.canvas.height - 20, angle: 0 };
                this.currentBubble = null;
                this.score = 0;
                this.isPlaying = false;
                this.lastTime = 0;
                this.canvas.addEventListener('mousemove', (e) => this.updateAngle(e));
                this.canvas.addEventListener('click', this.shootBubble.bind(this));
                this.canvas.addEventListener('touchstart', (e) => this.handleTouch(e));
                this.reset();
            }

            reset() {
                this.bubbles = [];
                this.currentBubble = this.createBubble();
                this.score = 0;
                this.isPlaying = true;
                this.messageBox.style.display = 'none';
                this.replayButton.style.display = 'none';
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 8; j++) {
                        this.bubbles.push({
                            x: j * 40 + 20,
                            y: i * 40 + 20,
                            radius: 15,
                            color: ['#ff2e63', '#4caf50', '#0288d1'][Math.floor(Math.random() * 3)]
                        });
                    }
                }
                this.gameLoop(0);
                createParticles(this.canvas.width / 2, this.canvas.height / 2, this.canvas.parentElement, 15, 'star');
            }

            createBubble() {
                return {
                    x: this.shooter.x,
                    y: this.shooter.y,
                    radius: 15,
                    color: ['#ff2e63', '#4caf50', '#0288d1'][Math.floor(Math.random() * 3)],
                    dx: 0,
                    dy: 0
                };
            }

            updateAngle(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                this.shooter.angle = Math.atan2(mouseY - this.shooter.y, mouseX - this.shooter.x);
            }

            handleTouch(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                this.shooter.angle = Math.atan2(touchY - this.shooter.y, touchX - this.shooter.x);
                this.shootBubble();
            }

            shootBubble() {
                if (!this.isPlaying || !this.currentBubble) return;
                this.currentBubble.dx = Math.cos(this.shooter.angle) * 5;
                this.currentBubble.dy = Math.sin(this.shooter.angle) * 5;
                createParticles(this.currentBubble.x, this.currentBubble.y, this.canvas.parentElement, 12, 'star');
            }

            update(delta) {
                if (!this.isPlaying) return;
                const dt = delta / 16.67;
                if (this.currentBubble) {
                    this.currentBubble.x += this.currentBubble.dx * dt;
                    this.currentBubble.y += this.currentBubble.dy * dt;
                    if (this.currentBubble.y < 0 || this.currentBubble.x < 0 || this.currentBubble.x > this.canvas.width) {
                        this.currentBubble = this.createBubble();
                    }
                    this.bubbles.forEach((bubble, index) => {
                        const dx = this.currentBubble.x - bubble.x;
                        const dy = this.currentBubble.y - bubble.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < this.currentBubble.radius + bubble.radius && this.currentBubble.color === bubble.color) {
                            this.bubbles.splice(index, 1);
                            this.score += 10;
                            this.currentBubble = this.createBubble();
                            createParticles(bubble.x, bubble.y, this.canvas.parentElement, 15, 'star');
                        }
                    });
                    if (this.bubbles.length === 0) {
                        this.isPlaying = false;
                        this.messageBox.innerText = `You Win! Score: ${this.score}`;
                        this.messageBox.style.display = 'block';
                        this.messageBox.classList.add('win-animation');
                        this.replayButton.style.display = 'inline-block';
                        createParticles(this.canvas.width / 2, this.canvas.height / 2, this.canvas.parentElement, 20, 'star');
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.bubbles.forEach(bubble => {
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = bubble.color;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                if (this.currentBubble) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.currentBubble.x, this.currentBubble.y, this.currentBubble.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.currentBubble.color;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.stroke();
                }
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '20px Poppins';
                this.ctx.fillText(`Score: ${this.score}`, 10, 30);
            }

            gameLoop = (timestamp) => {
                if (!this.lastTime) this.lastTime = timestamp;
                const delta = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(delta);
                this.draw();
                if (this.isPlaying) {
                    requestAnimationFrame(this.gameLoop);
                }
            }
        }

        // --- Input Throttling ---
        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.addEventListener('keydown', debounce(e => {
            if (snakeGame) snakeGame.changeDirection(e);
        }, 50));

        // --- Initialize First Game ---
        showGame('menu');
    </script>
</body>
</html>
