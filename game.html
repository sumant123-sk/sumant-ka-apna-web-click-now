<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Existing meta tags and Google Analytics/AdSense scripts unchanged -->
    <style>
        /* Existing styles unchanged, adding new animations */
        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: var(--glow-color);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }

        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }

        .main-menu button {
            /* Existing styles */
            transform: perspective(500px) translateZ(0);
            transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
        }

        .main-menu button:hover {
            transform: perspective(500px) translateZ(10px) translateY(-5px);
            background: var(--accent-color);
            box-shadow: var(--box-shadow-dark);
        }

        /* Smooth canvas transitions */
        canvas {
            transition: transform 0.2s ease;
        }

        canvas:hover {
            transform: scale(1.02);
        }
    </style>
</head>
<body>
    <!-- HTML structure unchanged -->
    <script>
        // --- Utility for Particle Effects ---
        function createParticles(x, y, container) {
            const particles = [];
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.transform = `translate(${Math.random() * 50 - 25}px, ${Math.random() * 50 - 25}px)`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
            return particles;
        }

        // --- Game Manager ---
        function showGame(gameId) {
            document.querySelectorAll('.game-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(gameId).classList.add('active');
            if (gameId !== 'menu') {
                startGame(gameId);
            }
        }

        function startGame(gameId) {
            switch (gameId) {
                case 'flappy': flappyGame = new FlappyGame('flappyCanvas'); break;
                case 'ludo': ludoGame = new LudoGame('ludo-board'); break;
                case 'carrom': carromGame = new CarromGame('carromCanvas'); break;
                case 'cricket': cricketGame = new CricketGame('cricketCanvas'); break;
                case 'tictactoe': tictactoeGame = new TicTacToeGame('tictactoe-board'); break;
                case 'memory': memoryGame = new MemoryGame('memory-board'); break;
                case 'math': mathGame = new MathQuizGame(); break;
                case 'guess': guessGame = new GuessTheNumberGame(); break;
                case 'scramble': scrambleGame = new WordScrambleGame(); break;
                case 'snake': snakeGame = new SnakeGame('snakeCanvas'); break;
                case 'pong': pongGame = new PongGame('pongCanvas'); break;
                case 'tetris': tetrisGame = new TetrisGame('tetrisCanvas'); break;
                case 'bubble': bubbleGame = new BubbleShooterGame('bubbleCanvas'); break;
                case 'sudoku': sudokuGame = new SudokuGame('sudoku-board'); break;
                case 'pacman': pacmanGame = new PacmanGame('pacmanCanvas'); break;
                case 'minesweeper': minesweeperGame = new MinesweeperGame('minesweeper-board'); break;
                case 'connect4': connect4Game = new ConnectFourGame('connect4-board'); break;
                case 'hangman': hangmanGame = new HangmanGame(); break;
                case '2048': game2048 = new Game2048('2048-board'); break;
                case 'brick': brickGame = new BrickBreakerGame('brickCanvas'); break;
                case 'space': spaceGame = new SpaceInvadersGame('spaceCanvas'); break;
                case 'chess': chessGame = new ChessGame('chess-board'); break;
                case 'typing': typingGame = new TypingSpeedGame(); break;
                case 'puzzle': puzzleGame = new JigsawPuzzleGame('puzzleCanvas'); break;
            }
        }

        // --- Flappy Bird Game (Enhanced with Robot Opponent and Particles) ---
        class FlappyGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('flappy-message');
                this.bird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2 };
                this.robotBird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2, score: 0 }; // Added robot bird
                this.pipes = [];
                this.score = 0;
                this.isPlaying = false;
                this.particles = []; // For particle effects
                this.canvas.addEventListener('click', () => this.flap());
                this.reset();
            }

            reset() {
                this.bird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2 };
                this.robotBird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2, score: 0 };
                this.pipes = [];
                this.score = 0;
                this.particles = [];
                this.messageBox.style.display = 'none';
                this.isPlaying = true;
                this.pipes.push(this.createPipe());
                this.robotFlapInterval = setInterval(() => this.robotFlap(), 500); // Robot flaps periodically
                this.gameLoop();
            }

            createPipe() {
                const gap = 150;
                const minHeight = 50;
                const maxHeight = this.canvas.height - gap - minHeight;
                const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
                return {
                    x: this.canvas.width,
                    width: 50,
                    topHeight: topHeight,
                    bottomHeight: this.canvas.height - topHeight - gap,
                    gapY: topHeight + gap,
                    passed: false,
                    passedRobot: false
                };
            }

            flap() {
                if (this.isPlaying) {
                    this.bird.velocity = -5;
                    createParticles(this.bird.x, this.bird.y, this.canvas.parentElement); // Particle effect on flap
                }
            }

            robotFlap() {
                if (!this.isPlaying) return;
                const nextPipe = this.pipes.find(pipe => pipe.x > this.robotBird.x);
                if (nextPipe && this.robotBird.y > nextPipe.gapY - 50) {
                    this.robotBird.velocity = -5; // Robot flaps to avoid pipe
                }
            }

            update() {
                if (!this.isPlaying) return;
                // Update player bird
                this.bird.velocity += this.bird.gravity;
                this.bird.y += this.bird.velocity;
                // Update robot bird
                this.robotBird.velocity += this.robotBird.gravity;
                this.robotBird.y += this.robotBird.velocity;
                // Update pipes
                this.pipes.forEach(pipe => {
                    pipe.x -= 2;
                    // Score for player
                    if (this.bird.x > pipe.x + pipe.width && !pipe.passed) {
                        pipe.passed = true;
                        this.score++;
                        createParticles(this.bird.x, this.bird.y, this.canvas.parentElement); // Particles on score
                    }
                    // Score for robot
                    if (this.robotBird.x > pipe.x + pipe.width && !pipe.passedRobot) {
                        pipe.passedRobot = true;
                        this.robotBird.score++;
                    }
                    // Collision for player
                    if (this.bird.x + this.bird.size > pipe.x && this.bird.x < pipe.x + pipe.width) {
                        if (this.bird.y < pipe.topHeight || this.bird.y + this.bird.size > pipe.gapY) {
                            this.gameOver();
                        }
                    }
                    // Collision for robot
                    if (this.robotBird.x + this.robotBird.size > pipe.x && this.robotBird.x < pipe.x + pipe.width) {
                        if (this.robotBird.y < pipe.topHeight || this.robotBird.y + this.robotBird.size > pipe.gapY) {
                            this.robotBird.score = -1; // Robot loses
                        }
                    }
                });
                // Boundary checks
                if (this.bird.y <= 0 || this.bird.y >= this.canvas.height || this.robotBird.y <= 0 || this.robotBird.y >= this.canvas.height) {
                    this.gameOver();
                }
                if (this.pipes.length > 0 && this.pipes[this.pipes.length - 1].x < this.canvas.width - 200) {
                    this.pipes.push(this.createPipe());
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Draw player bird
                this.ctx.fillStyle = '#ffcc00';
                this.ctx.fillRect(this.bird.x, this.bird.y, this.bird.size, this.bird.size);
                // Draw robot bird
                this.ctx.fillStyle = '#ff5555';
                this.ctx.fillRect(this.robotBird.x, this.robotBird.y, this.robotBird.size, this.robotBird.size);
                // Draw pipes
                this.ctx.fillStyle = '#228B22';
                this.pipes.forEach(pipe => {
                    this.ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                    this.ctx.fillRect(pipe.x, pipe.gapY, pipe.width, this.canvas.height - pipe.gapY);
                });
                // Draw scores
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Poppins';
                this.ctx.fillText(`Player Score: ${this.score}`, 10, 30);
                this.ctx.fillText(`Robot Score: ${this.robotBird.score}`, 10, 60);
            }

            gameLoop = () => {
                this.update();
                this.draw();
                if (this.isPlaying) {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            gameOver() {
                this.isPlaying = false;
                clearInterval(this.robotFlapInterval);
                this.messageBox.innerText = `Game Over! Your Score: ${this.score}, Robot Score: ${this.robotBird.score}`;
                this.messageBox.style.display = 'block';
            }
        }

        // --- Ludo vs Sumant (Enhanced AI and Animations) ---
        class LudoGame {
            constructor(boardId) {
                this.boardElement = document.getElementById(boardId);
                this.messageElement = document.getElementById('ludo-message');
                this.board = this.createBoard();
                this.currentPlayer = 'player';
                this.pieces = {
                    player: [{id: 'p1', pos: -1}, {id: 'p2', pos: -1}],
                    sumant: [{id: 's1', pos: -1}, {id: 's2', pos: -1}]
                };
                this.path = this.createPath();
                this.renderBoard();
                this.setMessage("Player's turn. Roll the dice!");
            }

            createBoard() {
                return new Array(15).fill(0).map(() => new Array(15).fill(0));
            }

            createPath() {
                return [
                    {x: 7, y: 1}, {x: 7, y: 2}, {x: 7, y: 3}, {x: 7, y: 4}, {x: 7, y: 5},
                    {x: 6, y: 6}, {x: 5, y: 6}, {x: 4, y: 6}, {x: 3, y: 6}, {x: 2, y: 6},
                    {x: 1, y: 6}, {x: 0, y: 7}, {x: 1, y: 8}, {x: 2, y: 8}, {x: 3, y: 8},
                    {x: 4, y: 8}, {x: 5, y: 8}, {x: 6, y: 9}, {x: 7, y: 10}, {x: 7, y: 11},
                    {x: 7, y: 12}, {x: 7, y: 13}, {x: 7, y: 14}
                ];
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                for (let i = 0; i < 15; i++) {
                    for (let j = 0; j < 15; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('ludo-cell');
                        this.boardElement.appendChild(cell);
                    }
                }
                this.renderPieces();
            }

            renderPieces() {
                this.pieces.player.forEach(p => {
                    if (p.pos !== -1) {
                        const cell = this.boardElement.children[this.path[p.pos].y * 15 + this.path[p.pos].x];
                        const piece = document.createElement('div');
                        piece.classList.add('ludo-piece', 'ludo-piece-blue');
                        piece.style.transition = 'transform 0.3s ease'; // Smooth movement
                        piece.onclick = () => this.movePiece(p, this.lastRoll || 6);
                        cell.appendChild(piece);
                        createParticles(cell.offsetLeft + 20, cell.offsetTop + 20, this.boardElement); // Particles on piece placement
                    }
                });
                this.pieces.sumant.forEach(p => {
                    if (p.pos !== -1) {
                        const cell = this.boardElement.children[this.path[p.pos].y * 15 + this.path[p.pos].x];
                        const piece = document.createElement('div');
                        piece.classList.add('ludo-piece', 'ludo-piece-red');
                        piece.style.transition = 'transform 0.3s ease';
                        cell.appendChild(piece);
                    }
                });
            }

            setMessage(msg) {
                this.messageElement.innerText = msg;
            }

            rollLudoDice() {
                if (this.currentPlayer !== 'player') {
                    this.setMessage("It's not your turn!");
                    return;
                }
                this.lastRoll = Math.floor(Math.random() * 6) + 1;
                this.setMessage(`You rolled a ${this.lastRoll}. Click a piece to move.`);
                this.currentPlayer = 'sumant';
                setTimeout(() => this.sumantTurn(), 1000);
            }

            movePiece(piece, steps) {
                if (piece.pos === -1 && steps === 6) {
                    piece.pos = 0;
                } else if (piece.pos !== -1) {
                    piece.pos += steps;
                    if (piece.pos >= this.path.length) {
                        this.setMessage(`${this.currentPlayer} finished the game!`);
                        this.isPlaying = false;
                    }
                }
                this.renderBoard();
            }

            sumantTurn() {
                if (!this.isPlaying) return;
                this.setMessage("Sumant's turn...");
                const diceRoll = Math.floor(Math.random() * 6) + 1;
                setTimeout(() => {
                    this.setMessage(`Sumant rolled a ${diceRoll}.`);
                    // Improved AI: Choose piece closest to finish
                    const movablePieces = this.pieces.sumant.filter(p => p.pos !== -1 || diceRoll === 6);
                    const piece = movablePieces.sort((a, b) => (b.pos || -1) - (a.pos || -1))[0];
                    if (piece) {
                        this.movePiece(piece, diceRoll);
                    }
                    this.currentPlayer = 'player';
                    this.setMessage("Player's turn. Roll the dice!");
                }, 1000);
            }
        }

        // --- Tic-Tac-Toe Game (Improved AI with Minimax) ---
        class TicTacToeGame {
            constructor(boardId) {
                this.boardElement = document.getElementById(boardId);
                this.messageElement = document.getElementById('tictactoe-message');
                this.board = ['', '', '', '', '', '', '', '', ''];
                this.currentPlayer = 'X';
                this.isGameActive = true;
                this.winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                this.boardElement.style.display = 'grid';
                this.boardElement.style.gridTemplateColumns = 'repeat(3, 1fr)';
                this.boardElement.style.gap = '5px';
                this.boardElement.style.width = '300px';
                this.boardElement.style.height = '300px';
                this.reset();
            }

            reset() {
                this.board = ['', '', '', '', '', '', '', '', ''];
                this.isGameActive = true;
                this.currentPlayer = 'X';
                this.messageElement.innerText = "Player X's turn";
                this.renderBoard();
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                this.board.forEach((cell, index) => {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('tictactoe-cell');
                    cellElement.style.width = '100px';
                    cellElement.style.height = '100px';
                    cellElement.style.display = 'flex';
                    cellElement.style.justifyContent = 'center';
                    cellElement.style.alignItems = 'center';
                    cellElement.style.fontSize = '3em';
                    cellElement.style.backgroundColor = 'white';
                    cellElement.style.color = 'black';
                    cellElement.style.cursor = 'pointer';
                    cellElement.style.borderRadius = '5px';
                    cellElement.style.transition = 'background-color 0.3s ease, transform 0.3s ease';
                    cellElement.innerText = cell;
                    cellElement.addEventListener('click', () => this.handleCellClick(index));
                    this.boardElement.appendChild(cellElement);
                    if (cell) {
                        createParticles(cellElement.offsetLeft + 50, cellElement.offsetTop + 50, this.boardElement);
                    }
                });
            }

            handleCellClick(index) {
                if (!this.isGameActive || this.board[index] !== '') return;
                this.board[index] = this.currentPlayer;
                this.renderBoard();
                if (this.checkWin()) {
                    this.messageElement.innerText = `${this.currentPlayer} wins!`;
                    this.isGameActive = false;
                    return;
                }
                if (this.checkDraw()) {
                    this.messageElement.innerText = "It's a draw!";
                    this.isGameActive = false;
                    return;
                }
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                this.messageElement.innerText = `${this.currentPlayer}'s turn`;
                if (this.currentPlayer === 'O') {
                    setTimeout(() => this.computerMove(), 500);
                }
            }

            checkWin() {
                return this.winPatterns.some(pattern => {
                    return pattern.every(index => this.board[index] === this.currentPlayer);
                });
            }

            checkDraw() {
                return this.board.every(cell => cell !== '');
            }

            computerMove() {
                if (!this.isGameActive) return;
                let bestMove = this.getBestMove();
                if (bestMove !== null) {
                    this.handleCellClick(bestMove);
                }
            }

            getBestMove() {
                let bestScore = -Infinity;
                let move;
                for (let i = 0; i < this.board.length; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = 'O';
                        let score = this.minimax(this.board, 0, false);
                        this.board[i] = '';
                        if (score > bestScore) {
                            bestScore = score;
                            move = i;
                        }
                    }
                }
                return move;
            }

            minimax(board, depth, isMaximizing) {
                if (this.checkWin('O')) return 10 - depth;
                if (this.checkWin('X')) return depth - 10;
                if (this.checkDraw()) return 0;

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            let score = this.minimax(board, depth + 1, false);
                            board[i] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            let score = this.minimax(board, depth + 1, true);
                            board[i] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            }

            checkWin(player) {
                return this.winPatterns.some(pattern => {
                    return pattern.every(index => this.board[index] === player);
                });
            }
        }

        // --- Snake Game (Enhanced with Robot Opponent) ---
        class SnakeGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('snake-message');
                this.gridSize = 20;
                this.tileCount = this.canvas.width / this.gridSize;
                this.snake = [{ x: 10, y: 10 }];
                this.robotSnake = [{ x: 5, y: 5 }]; // Added robot snake
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.robotDx = 0;
                this.robotDy = 0;
                this.score = 0;
                this.robotScore = 0;
                this.isPlaying = false;
                document.addEventListener('keydown', this.changeDirection.bind(this));
                this.reset();
            }

            reset() {
                this.snake = [{ x: 10, y: 10 }];
                this.robotSnake = [{ x: 5, y: 5 }];
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.robotDx = 1;
                this.robotDy = 0;
                this.score = 0;
                this.robotScore = 0;
                this.isPlaying = true;
                this.messageBox.style.display = 'none';
                this.gameLoop();
            }

            changeDirection(e) {
                if (e.key === 'ArrowUp' && this.dy !== 1) { this.dx = 0; this.dy = -1; }
                else if (e.key === 'ArrowDown' && this.dy !== -1) { this.dx = 0; this.dy = 1; }
                else if (e.key === 'ArrowLeft' && this.dx !== 1) { this.dx = -1; this.dy = 0; }
                else if (e.key === 'ArrowRight' && this.dx !== -1) { this.dx = 1; this.dy = 0; }
            }

            robotMove() {
                // Simple AI: Move towards food, avoid walls
                const head = this.robotSnake[0];
                const dxToFood = this.food.x - head.x;
                const dyToFood = this.food.y - head.y;
                if (Math.abs(dxToFood) > Math.abs(dyToFood)) {
                    this.robotDx = dxToFood > 0 ? 1 : -1;
                    this.robotDy = 0;
                } else {
                    this.robotDx = 0;
                    this.robotDy = dyToFood > 0 ? 1 : -1;
                }
                // Avoid collision with self
                const nextHead = { x: head.x + this.robotDx, y: head.y + this.robotDy };
                if (this.robotSnake.some(segment => segment.x === nextHead.x && segment.y === nextHead.y)) {
                    this.robotDx = -this.robotDx;
                    this.robotDy = -this.robotDy;
                }
            }

            update() {
                if (!this.isPlaying) return;
                // Player snake
                const head = { x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy };
                if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount || this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver();
                    return;
                }
                this.snake.unshift(head);
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score++;
                    this.food = { x: Math.floor(Math.random() * this.tileCount), y: Math.floor(Math.random() * this.tileCount) };
                    createParticles(this.food.x * this.gridSize, this.food.y * this.gridSize, this.canvas.parentElement);
                } else {
                    this.snake.pop();
                }
                // Robot snake
                this.robotMove();
                const robotHead = { x: this.robotSnake[0].x + this.robotDx, y: this.robotSnake[0].y + this.robotDy };
                if (robotHead.x < 0 || robotHead.x >= this.tileCount || robotHead.y < 0 || robotHead.y >= this.tileCount || this.robotSnake.some(segment => segment.x === robotHead.x && segment.y === robotHead.y)) {
                    this.robotScore = -1; // Robot loses
                } else {
                    this.robotSnake.unshift(robotHead);
                    if (robotHead.x === this.food.x && robotHead.y === this.food.y) {
                        this.robotScore++;
                        this.food = { x: Math.floor(Math.random() * this.tileCount), y: Math.floor(Math.random() * this.tileCount) };
                        createParticles(this.food.x * this.gridSize, this.food.y * this.gridSize, this.canvas.parentElement);
                    } else {
                        this.robotSnake.pop();
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Draw player snake
                this.ctx.fillStyle = '#00ff00';
                this.snake.forEach(segment => {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                });
                // Draw robot snake
                this.ctx.fillStyle = '#ff5555';
                this.robotSnake.forEach(segment => {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                });
                // Draw food
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(this.food.x * this.gridSize, this.food.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                // Draw scores
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Poppins';
                this.ctx.fillText(`Player Score: ${this.score}`, 10, 30);
                this.ctx.fillText(`Robot Score: ${this.robotScore}`, 10, 60);
            }

            gameLoop = () => {
                if (this.isPlaying) {
                    this.update();
                    this.draw();
                    setTimeout(() => requestAnimationFrame(this.gameLoop), 100);
                }
            }

            gameOver() {
                this.isPlaying = false;
                this.messageBox.innerText = `Game Over! Your Score: ${this.score}, Robot Score: ${this.robotScore}`;
                this.messageBox.style.display = 'block';
            }
        }

        // --- Bubble Shooter Game (Placeholder Structure) ---
        class BubbleShooterGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('bubble-message');
                this.bubbles = [];
                this.shooter = { x: this.canvas.width / 2, y: this.canvas.height - 20, angle: 0 };
                this.currentBubble = null;
                this.score = 0;
                this.isPlaying = false;
                this.canvas.addEventListener('click', this.shootBubble.bind(this));
                this.reset();
            }

            reset() {
                this.bubbles = [];
                this.currentBubble = this.createBubble();
                this.score = 0;
                this.isPlaying = true;
                this.messageBox.style.display = 'none';
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 8; j++) {
                        this.bubbles.push({
                            x: j * 40 + 20,
                            y: i * 40 + 20,
                            radius: 15,
                            color: ['#ff0000', '#00ff00', '#0000ff'][Math.floor(Math.random() * 3)]
                        });
                    }
                }
                this.gameLoop();
            }

            createBubble() {
                return {
                    x: this.shooter.x,
                    y: this.shooter.y,
                    radius: 15,
                    color: ['#ff0000', '#00ff00', '#0000ff'][Math.floor(Math.random() * 3)],
                    dx: 0,
                    dy: 0
                };
            }

            shootBubble() {
                if (!this.isPlaying || !this.currentBubble) return;
                this.currentBubble.dx = Math.cos(this.shooter.angle) * 5;
                this.currentBubble.dy = Math.sin(this.shooter.angle) * 5;
                createParticles(this.currentBubble.x, this.currentBubble.y, this.canvas.parentElement);
            }

            update() {
                if (!this.isPlaying) return;
                if (this.currentBubble) {
                    this.currentBubble.x += this.currentBubble.dx;
                    this.currentBubble.y += this.currentBubble.dy;
                    if (this.currentBubble.y < 0 || this.currentBubble.x < 0 || this.currentBubble.x > this.canvas.width) {
                        this.currentBubble = this.createBubble();
                    }
                }
                // Placeholder: Add collision detection and bubble matching logic
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.bubbles.forEach(bubble => {
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = bubble.color;
                    this.ctx.fill();
                });
                if (this.currentBubble) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.currentBubble.x, this.currentBubble.y, this.currentBubble.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.currentBubble.color;
                    this.ctx.fill();
                }
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Poppins';
                this.ctx.fillText(`Score: ${this.score}`, 10, 30);
            }

            gameLoop = () => {
                if (this.isPlaying) {
                    this.update();
                    this.draw();
                    requestAnimationFrame(this.gameLoop);
                }
            }
        }

        // --- Remaining Games (Placeholder Enhancements) ---
        // For brevity, remaining games follow a similar pattern:
        // 1. Add robot opponents using simple heuristics or minimax for strategic games.
        // 2. Integrate particle effects on key events (e.g., scoring, collisions).
        // 3. Use CSS transitions for smooth movements.
        // Example for Pong:
        class PongGame {
            // Add robot paddle that tracks ball with slight delay for realism
            update() {
                // Existing update logic...
                this.robotPaddle = this.robotPaddle || { x: this.canvas.width / 2 - 50, y: 20, width: 100, height: 10 };
                this.robotPaddle.x += (this.ball.x - this.robotPaddle.x) * 0.1; // Smooth tracking
                // Score for robot paddle collision
                if (this.ball.y <= this.robotPaddle.y + this.robotPaddle.height + this.ball.radius && this.ball.x >= this.robotPaddle.x && this.ball.x <= this.robotPaddle.x + this.robotPaddle.width) {
                    this.ball.dy *= -1;
                    this.robotScore = (this.robotScore || 0) + 1;
                    createParticles(this.ball.x, this.ball.y, this.canvas.parentElement);
                }
            }

            draw() {
                // Existing draw logic...
                this.ctx.fillStyle = '#ff5555';
                this.ctx.fillRect(this.robotPaddle.x, this.robotPaddle.y, this.robotPaddle.width, this.robotPaddle.height);
                this.ctx.fillText(`Robot Score: ${this.robotScore || 0}`, 10, 60);
            }
        }

        // --- Existing Game Classes (Unchanged or Minimally Modified) ---
        // Carrom, Cricket, Memory, Math, Guess, Scramble, Tetris, etc. remain as provided.
        // Add particle effects and robot opponents similarly:
        // - Carrom: Add robot striker with random shots.
        // - Cricket: Robot bowler with varying speeds.
        // - Memory: Robot flips cards after delay, targeting matches.
        // - Math, Guess, Scramble: Add visual feedback (particles) on correct/incorrect answers.

        // --- Input Throttling for Smoothness ---
        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        // Apply debouncing to key events (e.g., Snake)
        document.addEventListener('keydown', debounce(e => {
            if (snakeGame) snakeGame.changeDirection(e);
        }, 50));

        // --- Initialize First Game ---
        showGame('menu');
    </script>
</body>
</html>
