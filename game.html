<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>25-in-1 Game Center</title>
    <style>
        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .game-section {
            display: none;
            text-align: center;
        }
        .game-section.active {
            display: block;
        }
        .main-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .main-menu button {
            padding: 15px 30px;
            font-size: 18px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transform: perspective(500px) translateZ(0);
            transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
        }
        .main-menu button:hover {
            transform: perspective(500px) translateZ(10px) translateY(-5px);
            background: #ff5555;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        canvas {
            background: #000;
            border: 2px solid #fff;
            transition: transform 0.2s ease;
        }
        canvas:hover {
            transform: scale(1.02);
        }
        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: #00ffff;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }
        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }
        .ludo-cell {
            width: 30px;
            height: 30px;
            background: #333;
            border: 1px solid #555;
            display: inline-block;
        }
        .ludo-piece {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
        }
        .ludo-piece-blue { background: #00f; }
        .ludo-piece-red { background: #f00; }
        .tictactoe-cell {
            background: #fff;
            color: #000;
            cursor: pointer;
            border-radius: 5px;
        }
        :root {
            --glow-color: #00ffff;
            --accent-color: #ff5555;
            --box-shadow-dark: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="menu" class="game-section active">
        <h1>25-in-1 Game Center</h1>
        <div class="main-menu">
            <button onclick="showGame('flappy')">Flappy Bird</button>
            <button onclick="showGame('ludo')">Ludo vs Sumant</button>
            <button onclick="showGame('tictactoe')">Tic-Tac-Toe</button>
            <button onclick="showGame('snake')">Snake</button>
            <button onclick="showGame('bubble')">Bubble Shooter</button>
        </div>
    </div>
    <div id="flappy" class="game-section">
        <canvas id="flappyCanvas" width="400" height="600"></canvas>
        <div id="flappy-message"></div>
    </div>
    <div id="ludo" class="game-section">
        <div id="ludo-board" style="display: grid; grid-template-columns: repeat(15, 30px);"></div>
        <div id="ludo-message"></div>
        <button onclick="ludoGame.rollLudoDice()">Roll Dice</button>
    </div>
    <div id="tictactoe" class="game-section">
        <div id="tictactoe-board"></div>
        <div id="tictactoe-message"></div>
    </div>
    <div id="snake" class="game-section">
        <canvas id="snakeCanvas" width="400" height="400"></canvas>
        <div id="snake-message"></div>
    </div>
    <div id="bubble" class="game-section">
        <canvas id="bubbleCanvas" width="400" height="400"></canvas>
        <div id="bubble-message"></div>
    </div>

    <script>
        // --- Utility for Particle Effects ---
        function createParticles(x, y, container) {
            const particles = [];
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.transform = `translate(${Math.random() * 50 - 25}px, ${Math.random() * 50 - 25}px)`;
                container.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
            return particles;
        }

        // --- Game Manager ---
        let flappyGame, ludoGame, tictactoeGame, snakeGame, bubbleGame;
        function showGame(gameId) {
            document.querySelectorAll('.game-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(gameId).classList.add('active');
            if (gameId !== 'menu') {
                startGame(gameId);
            }
        }

        function startGame(gameId) {
            switch (gameId) {
                case 'flappy': flappyGame = new FlappyGame('flappyCanvas'); break;
                case 'ludo': ludoGame = new LudoGame('ludo-board'); break;
                case 'tictactoe': tictactoeGame = new TicTacToeGame('tictactoe-board'); break;
                case 'snake': snakeGame = new SnakeGame('snakeCanvas'); break;
                case 'bubble': bubbleGame = new BubbleShooterGame('bubbleCanvas'); break;
            }
        }

        // --- Flappy Bird Game ---
        class FlappyGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('flappy-message');
                this.bird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2 };
                this.robotBird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2, score: 0 };
                this.pipes = [];
                this.score = 0;
                this.isPlaying = false;
                this.canvas.addEventListener('click', () => this.flap());
                this.reset();
            }

            reset() {
                this.bird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2 };
                this.robotBird = { x: 50, y: this.canvas.height / 2, size: 20, velocity: 0, gravity: 0.2, score: 0 };
                this.pipes = [];
                this.score = 0;
                this.messageBox.style.display = 'none';
                this.isPlaying = true;
                this.pipes.push(this.createPipe());
                this.robotFlapInterval = setInterval(() => this.robotFlap(), 500);
                this.gameLoop();
            }

            createPipe() {
                const gap = 150;
                const minHeight = 50;
                const maxHeight = this.canvas.height - gap - minHeight;
                const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
                return {
                    x: this.canvas.width,
                    width: 50,
                    topHeight: topHeight,
                    bottomHeight: this.canvas.height - topHeight - gap,
                    gapY: topHeight + gap,
                    passed: false,
                    passedRobot: false
                };
            }

            flap() {
                if (this.isPlaying) {
                    this.bird.velocity = -5;
                    createParticles(this.bird.x, this.bird.y, this.canvas.parentElement);
                }
            }

            robotFlap() {
                if (!this.isPlaying) return;
                const nextPipe = this.pipes.find(pipe => pipe.x > this.robotBird.x);
                if (nextPipe && this.robotBird.y > nextPipe.gapY - 50) {
                    this.robotBird.velocity = -5;
                }
            }

            update() {
                if (!this.isPlaying) return;
                this.bird.velocity += this.bird.gravity;
                this.bird.y += this.bird.velocity;
                this.robotBird.velocity += this.robotBird.gravity;
                this.robotBird.y += this.robotBird.velocity;
                this.pipes.forEach(pipe => {
                    pipe.x -= 2;
                    if (this.bird.x > pipe.x + pipe.width && !pipe.passed) {
                        pipe.passed = true;
                        this.score++;
                        createParticles(this.bird.x, this.bird.y, this.canvas.parentElement);
                    }
                    if (this.robotBird.x > pipe.x + pipe.width && !pipe.passedRobot) {
                        pipe.passedRobot = true;
                        this.robotBird.score++;
                    }
                    if (this.bird.x + this.bird.size > pipe.x && this.bird.x < pipe.x + pipe.width) {
                        if (this.bird.y < pipe.topHeight || this.bird.y + this.bird.size > pipe.gapY) {
                            this.gameOver();
                        }
                    }
                    if (this.robotBird.x + this.robotBird.size > pipe.x && this.robotBird.x < pipe.x + pipe.width) {
                        if (this.robotBird.y < pipe.topHeight || this.robotBird.y + this.robotBird.size > pipe.gapY) {
                            this.robotBird.score = -1;
                        }
                    }
                });
                if (this.bird.y <= 0 || this.bird.y >= this.canvas.height || this.robotBird.y <= 0 || this.robotBird.y >= this.canvas.height) {
                    this.gameOver();
                }
                if (this.pipes.length > 0 && this.pipes[this.pipes.length - 1].x < this.canvas.width - 200) {
                    this.pipes.push(this.createPipe());
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ffcc00';
                this.ctx.fillRect(this.bird.x, this.bird.y, this.bird.size, this.bird.size);
                this.ctx.fillStyle = '#ff5555';
                this.ctx.fillRect(this.robotBird.x, this.robotBird.y, this.robotBird.size, this.robotBird.size);
                this.ctx.fillStyle = '#228B22';
                this.pipes.forEach(pipe => {
                    this.ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                    this.ctx.fillRect(pipe.x, pipe.gapY, pipe.width, this.canvas.height - pipe.gapY);
                });
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Poppins';
                this.ctx.fillText(`Player Score: ${this.score}`, 10, 30);
                this.ctx.fillText(`Robot Score: ${this.robotBird.score}`, 10, 60);
            }

            gameLoop = () => {
                this.update();
                this.draw();
                if (this.isPlaying) {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            gameOver() {
                this.isPlaying = false;
                clearInterval(this.robotFlapInterval);
                this.messageBox.innerText = `Game Over! Your Score: ${this.score}, Robot Score: ${this.robotBird.score}`;
                this.messageBox.style.display = 'block';
            }
        }

        // --- Ludo vs Sumant ---
        class LudoGame {
            constructor(boardId) {
                this.boardElement = document.getElementById(boardId);
                this.messageElement = document.getElementById('ludo-message');
                this.board = this.createBoard();
                this.currentPlayer = 'player';
                this.pieces = {
                    player: [{id: 'p1', pos: -1}, {id: 'p2', pos: -1}],
                    sumant: [{id: 's1', pos: -1}, {id: 's2', pos: -1}]
                };
                this.path = this.createPath();
                this.isPlaying = true;
                this.renderBoard();
                this.setMessage("Player's turn. Roll the dice!");
            }

            createBoard() {
                return new Array(15).fill(0).map(() => new Array(15).fill(0));
            }

            createPath() {
                return [
                    {x: 7, y: 1}, {x: 7, y: 2}, {x: 7, y: 3}, {x: 7, y: 4}, {x: 7, y: 5},
                    {x: 6, y: 6}, {x: 5, y: 6}, {x: 4, y: 6}, {x: 3, y: 6}, {x: 2, y: 6},
                    {x: 1, y: 6}, {x: 0, y: 7}, {x: 1, y: 8}, {x: 2, y: 8}, {x: 3, y: 8},
                    {x: 4, y: 8}, {x: 5, y: 8}, {x: 6, y: 9}, {x: 7, y: 10}, {x: 7, y: 11},
                    {x: 7, y: 12}, {x: 7, y: 13}, {x: 7, y: 14}
                ];
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                for (let i = 0; i < 15; i++) {
                    for (let j = 0; j < 15; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('ludo-cell');
                        this.boardElement.appendChild(cell);
                    }
                }
                this.renderPieces();
            }

            renderPieces() {
                this.pieces.player.forEach(p => {
                    if (p.pos !== -1) {
                        const cell = this.boardElement.children[this.path[p.pos].y * 15 + this.path[p.pos].x];
                        const piece = document.createElement('div');
                        piece.classList.add('ludo-piece', 'ludo-piece-blue');
                        piece.style.transition = 'transform 0.3s ease';
                        piece.onclick = () => this.movePiece(p, this.lastRoll || 6);
                        cell.appendChild(piece);
                        createParticles(cell.offsetLeft + 20, cell.offsetTop + 20, this.boardElement);
                    }
                });
                this.pieces.sumant.forEach(p => {
                    if (p.pos !== -1) {
                        const cell = this.boardElement.children[this.path[p.pos].y * 15 + this.path[p.pos].x];
                        const piece = document.createElement('div');
                        piece.classList.add('ludo-piece', 'ludo-piece-red');
                        piece.style.transition = 'transform 0.3s ease';
                        cell.appendChild(piece);
                    }
                });
            }

            setMessage(msg) {
                this.messageElement.innerText = msg;
            }

            rollLudoDice() {
                if (this.currentPlayer !== 'player') {
                    this.setMessage("It's not your turn!");
                    return;
                }
                this.lastRoll = Math.floor(Math.random() * 6) + 1;
                this.setMessage(`You rolled a ${this.lastRoll}. Click a piece to move.`);
                this.currentPlayer = 'sumant';
                setTimeout(() => this.sumantTurn(), 1000);
            }

            movePiece(piece, steps) {
                if (piece.pos === -1 && steps === 6) {
                    piece.pos = 0;
                } else if (piece.pos !== -1) {
                    piece.pos += steps;
                    if (piece.pos >= this.path.length) {
                        this.setMessage(`${this.currentPlayer} finished the game!`);
                        this.isPlaying = false;
                    }
                }
                this.renderBoard();
            }

            sumantTurn() {
                if (!this.isPlaying) return;
                this.setMessage("Sumant's turn...");
                const diceRoll = Math.floor(Math.random() * 6) + 1;
                setTimeout(() => {
                    this.setMessage(`Sumant rolled a ${diceRoll}.`);
                    const movablePieces = this.pieces.sumant.filter(p => p.pos !== -1 || diceRoll === 6);
                    const piece = movablePieces.sort((a, b) => (b.pos || -1) - (a.pos || -1))[0];
                    if (piece) {
                        this.movePiece(piece, diceRoll);
                    }
                    this.currentPlayer = 'player';
                    this.setMessage("Player's turn. Roll the dice!");
                }, 1000);
            }
        }

        // --- Tic-Tac-Toe Game ---
        class TicTacToeGame {
            constructor(boardId) {
                this.boardElement = document.getElementById(boardId);
                this.messageElement = document.getElementById('tictactoe-message');
                this.board = ['', '', '', '', '', '', '', '', ''];
                this.currentPlayer = 'X';
                this.isGameActive = true;
                this.winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                this.boardElement.style.display = 'grid';
                this.boardElement.style.gridTemplateColumns = 'repeat(3, 1fr)';
                this.boardElement.style.gap = '5px';
                this.boardElement.style.width = '300px';
                this.boardElement.style.height = '300px';
                this.reset();
            }

            reset() {
                this.board = ['', '', '', '', '', '', '', '', ''];
                this.isGameActive = true;
                this.currentPlayer = 'X';
                this.messageElement.innerText = "Player X's turn";
                this.renderBoard();
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                this.board.forEach((cell, index) => {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('tictactoe-cell');
                    cellElement.style.width = '100px';
                    cellElement.style.height = '100px';
                    cellElement.style.display = 'flex';
                    cellElement.style.justifyContent = 'center';
                    cellElement.style.alignItems = 'center';
                    cellElement.style.fontSize = '3em';
                    cellElement.style.backgroundColor = 'white';
                    cellElement.style.color = 'black';
                    cellElement.style.cursor = 'pointer';
                    cellElement.style.borderRadius = '5px';
                    cellElement.style.transition = 'background-color 0.3s ease, transform 0.3s ease';
                    cellElement.innerText = cell;
                    cellElement.addEventListener('click', () => this.handleCellClick(index));
                    this.boardElement.appendChild(cellElement);
                    if (cell) {
                        createParticles(cellElement.offsetLeft + 50, cellElement.offsetTop + 50, this.boardElement);
                    }
                });
            }

            handleCellClick(index) {
                if (!this.isGameActive || this.board[index] !== '') return;
                this.board[index] = this.currentPlayer;
                this.renderBoard();
                if (this.checkWin()) {
                    this.messageElement.innerText = `${this.currentPlayer} wins!`;
                    this.isGameActive = false;
                    return;
                }
                if (this.checkDraw()) {
                    this.messageElement.innerText = "It's a draw!";
                    this.isGameActive = false;
                    return;
                }
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                this.messageElement.innerText = `${this.currentPlayer}'s turn`;
                if (this.currentPlayer === 'O') {
                    setTimeout(() => this.computerMove(), 500);
                }
            }

            checkWin() {
                return this.winPatterns.some(pattern => {
                    return pattern.every(index => this.board[index] === this.currentPlayer);
                });
            }

            checkDraw() {
                return this.board.every(cell => cell !== '');
            }

            computerMove() {
                if (!this.isGameActive) return;
                let bestMove = this.getBestMove();
                if (bestMove !== null) {
                    this.handleCellClick(bestMove);
                }
            }

            getBestMove() {
                let bestScore = -Infinity;
                let move;
                for (let i = 0; i < this.board.length; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = 'O';
                        let score = this.minimax(this.board, 0, false);
                        this.board[i] = '';
                        if (score > bestScore) {
                            bestScore = score;
                            move = i;
                        }
                    }
                }
                return move;
            }

            minimax(board, depth, isMaximizing) {
                if (this.checkWin('O')) return 10 - depth;
                if (this.checkWin('X')) return depth - 10;
                if (this.checkDraw()) return 0;

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (leti = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            let score = this.minimax(board, depth + 1, false);
                            board[i] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            let score = this.minimax(board, depth + 1, true);
                            board[i] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            }

            checkWin(player) {
                return this.winPatterns.some(pattern => {
                    return pattern.every(index => this.board[index] === player);
                });
            }
        }

        // --- Snake Game ---
        class SnakeGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('snake-message');
                this.gridSize = 20;
                this.tileCount = this.canvas.width / this.gridSize;
                this.snake = [{ x: 10, y: 10 }];
                this.robotSnake = [{ x: 5, y: 5 }];
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.robotDx = 1;
                this.robotDy = 0;
                this.score = 0;
                this.robotScore = 0;
                this.isPlaying = false;
                document.addEventListener('keydown', this.changeDirection.bind(this));
                this.reset();
            }

            reset() {
                this.snake = [{ x: 10, y: 10 }];
                this.robotSnake = [{ x: 5, y: 5 }];
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.robotDx = 1;
                this.robotDy = 0;
                this.score = 0;
                this.robotScore = 0;
                this.isPlaying = true;
                this.messageBox.style.display = 'none';
                this.gameLoop();
            }

            changeDirection(e) {
                if (e.key === 'ArrowUp' && this.dy !== 1) { this.dx = 0; this.dy = -1; }
                else if (e.key === 'ArrowDown' && this.dy !== -1) { this.dx = 0; this.dy = 1; }
                else if (e.key === 'ArrowLeft' && this.dx !== 1) { this.dx = -1; this.dy = 0; }
                else if (e.key === 'ArrowRight' && this.dx !== -1) { this.dx = 1; this.dy = 0; }
            }

            robotMove() {
                const head = this.robotSnake[0];
                const dxToFood = this.food.x - head.x;
                const dyToFood = this.food.y - head.y;
                if (Math.abs(dxToFood) > Math.abs(dyToFood)) {
                    this.robotDx = dxToFood > 0 ? 1 : -1;
                    this.robotDy = 0;
                } else {
                    this.robotDx = 0;
                    this.robotDy = dyToFood > 0 ? 1 : -1;
                }
                const nextHead = { x: head.x + this.robotDx, y: head.y + this.robotDy };
                if (this.robotSnake.some(segment => segment.x === nextHead.x && segment.y === nextHead.y)) {
                    this.robotDx = -this.robotDx;
                    this.robotDy = -this.robotDy;
                }
            }

            update() {
                if (!this.isPlaying) return;
                const head = { x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy };
                if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount || this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver();
                    return;
                }
                this.snake.unshift(head);
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score++;
                    this.food = { x: Math.floor(Math.random() * this.tileCount), y: Math.floor(Math.random() * this.tileCount) };
                    createParticles(this.food.x * this.gridSize, this.food.y * this.gridSize, this.canvas.parentElement);
                } else {
                    this.snake.pop();
                }
                this.robotMove();
                const robotHead = { x: this.robotSnake[0].x + this.robotDx, y: this.robotSnake[0].y + this.robotDy };
                if (robotHead.x < 0 || robotHead.x >= this.tileCount || robotHead.y < 0 || robotHead.y >= this.tileCount || this.robotSnake.some(segment => segment.x === robotHead.x && segment.y === robotHead.y)) {
                    this.robotScore = -1;
                } else {
                    this.robotSnake.unshift(robotHead);
                    if (robotHead.x === this.food.x && robotHead.y === this.food.y) {
                        this.robotScore++;
                        this.food = { x: Math.floor(Math.random() * this.tileCount), y: Math.floor(Math.random() * this.tileCount) };
                        createParticles(this.food.x * this.gridSize, this.food.y * this.gridSize, this.canvas.parentElement);
                    } else {
                        this.robotSnake.pop();
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#00ff00';
                this.snake.forEach(segment => {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                });
                this.ctx.fillStyle = '#ff5555';
                this.robotSnake.forEach(segment => {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                });
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(this.food.x * this.gridSize, this.food.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Poppins';
                this.ctx.fillText(`Player Score: ${this.score}`, 10, 30);
                this.ctx.fillText(`Robot Score: ${this.robotScore}`, 10, 60);
            }

            gameLoop = () => {
                if (this.isPlaying) {
                    this.update();
                    this.draw();
                    setTimeout(() => requestAnimationFrame(this.gameLoop), 100);
                }
            }

            gameOver() {
                this.isPlaying = false;
                this.messageBox.innerText = `Game Over! Your Score: ${this.score}, Robot Score: ${this.robotScore}`;
                this.messageBox.style.display = 'block';
            }
        }

        // --- Bubble Shooter Game ---
        class BubbleShooterGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.messageBox = document.getElementById('bubble-message');
                this.bubbles = [];
                this.shooter = { x: this.canvas.width / 2, y: this.canvas.height - 20, angle: 0 };
                this.currentBubble = null;
                this.score = 0;
                this.isPlaying = false;
                this.canvas.addEventListener('mousemove', (e) => this.updateAngle(e));
                this.canvas.addEventListener('click', this.shootBubble.bind(this));
                this.reset();
            }

            reset() {
                this.bubbles = [];
                this.currentBubble = this.createBubble();
                this.score = 0;
                this.isPlaying = true;
                this.messageBox.style.display = 'none';
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 8; j++) {
                        this.bubbles.push({
                            x: j * 40 + 20,
                            y: i * 40 + 20,
                            radius: 15,
                            color: ['#ff0000', '#00ff00', '#0000ff'][Math.floor(Math.random() * 3)]
                        });
                    }
                }
                this.gameLoop();
            }

            createBubble() {
                return {
                    x: this.shooter.x,
                    y: this.shooter.y,
                    radius: 15,
                    color: ['#ff0000', '#00ff00', '#0000ff'][Math.floor(Math.random() * 3)],
                    dx: 0,
                    dy: 0
                };
            }

            updateAngle(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                this.shooter.angle = Math.atan2(mouseY - this.shooter.y, mouseX - this.shooter.x);
            }

            shootBubble() {
                if (!this.isPlaying || !this.currentBubble) return;
                this.currentBubble.dx = Math.cos(this.shooter.angle) * 5;
                this.currentBubble.dy = Math.sin(this.shooter.angle) * 5;
                createParticles(this.currentBubble.x, this.currentBubble.y, this.canvas.parentElement);
            }

            update() {
                if (!this.isPlaying) return;
                if (this.currentBubble) {
                    this.currentBubble.x += this.currentBubble.dx;
                    this.currentBubble.y += this.currentBubble.dy;
                    if (this.currentBubble.y < 0 || this.currentBubble.x < 0 || this.currentBubble.x > this.canvas.width) {
                        this.currentBubble = this.createBubble();
                    }
                    this.bubbles.forEach((bubble, index) => {
                        const dx = this.currentBubble.x - bubble.x;
                        const dy = this.currentBubble.y - bubble.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < this.currentBubble.radius + bubble.radius && this.currentBubble.color === bubble.color) {
                            this.bubbles.splice(index, 1);
                            this.score += 10;
                            this.currentBubble = this.createBubble();
                            createParticles(bubble.x, bubble.y, this.canvas.parentElement);
                        }
                    });
                    if (this.bubbles.length === 0) {
                        this.isPlaying = false;
                        this.messageBox.innerText = `You Win! Score: ${this.score}`;
                        this.messageBox.style.display = 'block';
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.bubbles.forEach(bubble => {
                    this.ctx.beginPath();
                    this.ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = bubble.color;
                    this.ctx.fill();
                });
                if (this.currentBubble) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.currentBubble.x, this.currentBubble.y, this.currentBubble.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.currentBubble.color;
                    this.ctx.fill();
                }
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Poppins';
                this.ctx.fillText(`Score: ${this.score}`, 10, 30);
            }

            gameLoop = () => {
                if (this.isPlaying) {
                    this.update();
                    this.draw();
                    requestAnimationFrame(this.gameLoop);
                }
            }
        }

        // --- Input Throttling ---
        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.addEventListener('keydown', debounce(e => {
            if (snakeGame) snakeGame.changeDirection(e);
        }, 50));

        // --- Initialize First Game ---
        showGame('menu');
    </script>
</body>
</html>
